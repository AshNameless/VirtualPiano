提交开题报告之后：
  3.15：
  玩了多天后，多方搜集资料，开始拟采用加法合成，在他人论文中收音符的谐波的参数，包括adsr参数，用python脚本合成音频，但听觉效果不理想。
  目前倾向减法合成，但依然可以用一个单独正弦波完成输出，音色的效果可以后续再进行调整。

  3.19:
  对PLL ip核进行仿真完成，仿真时(应该是的)modelsim不支持bdf仿真耗费了不少时间，需要将图形文件转化为.vhd文件才能仿真。NCO ip核拟采用输入50_mhz时钟，相位累加器精度25bits，angular和幅值精度16bits
  花了一下午的时间，终于把nco的仿真弄出来了。直接用Modelsim仿真可能会失败，再去work library里重新编译一下文件就好。testbench重写之后也只需要重写编译然后右键simulate,再add之后命令行输入run即可不用关闭modelsim再次仿真。
  NCO的另一个输入端口为clk_en,rst低电平有效，需要输出时候rst应设为高电平。

  3.21:
  对ip核仿真基本掌握，着手实现音频部分。利用vhdl的package把一些数据宽度等用常量保存，函数也装在package中，这样后续修改数据宽度时只需要修改package并重新编译顶层文件即可，比较方便
  
  3.22:
  对audio_controller的状态机做了分析并实现了一些，同时学会了用graphviz画图(画状态机、流程图很方便)，将音符和phase_step通过constant的形式存储在了constants.vhd的package中

  3.26:
  audio_controller实现完成，adsr状态机的状态已绘制完成。由于再实现asdr时需要将NCO输出与系数相乘，做乘法这步需要具体决定。板子的音频模块是24位的，因此修改NCO输出为12位，将其转化为原码后直接与12位系数相乘得到24位结果，再输出到板子的音频模块。

  3.27:
  板子上wm8731可以用来播放wav音频，而wav默认又采用二进制补码表示。因此，NCO输出的数据就不转换，将系数转化为补码后直接相乘并输出即可。采用ieee.numeric_std包完成码制转换和乘法。
  
  4.1:
  ADSR模块调试完成。至此，从识别模块输入24位识别信号，转换成24位单个音符信号（先只实现单个音符），然后控制NCO输出频率，并将输出正弦波通过ADSR进行整形，这整个过程基本完成。整形后的波形给到输出部分，拟利用板子上的wm8731进行输出，不过相关信息不多，数据手册看的云里雾里，对8731的使用方式仍一知半解。
  



